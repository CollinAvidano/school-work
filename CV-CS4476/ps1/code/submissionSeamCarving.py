
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# Edit SeamCarving.ipynb instead.
import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage, signal
from imageio import imread, imsave

def  rgb2gray(img):
    """
    Converts an RGB image into a greyscale image

    Input: ndarray of an RGB image of shape (H x W x 3)
    Output: ndarray of the corresponding grayscale image of shape (H x W)

    """

    if(img.ndim != 3 or img.shape[-1] != 3):
        print("Invalid image! Please provide an RGB image of the shape (H x W x 3) instead.".format(img.ndim))
        return None

    return np.dot(img[...,:3], [0.2989, 0.5870, 0.1140])

def compute_gradients(img):
    """
    Computes the gradients of the input image in the x and y direction using a
    differentiation filter.

    ##########################################################################
    # TODO: Design a differentiation filter and update the docstring. Stick  #
    # to a pure differentiation filter for this assignment.                  #
    # Hint: Look at Slide 14 from Lecture 3: Gradients.                      #
    ##########################################################################

    Input: Grayscale image of shape (H x W)
    Outputs: gx, gy gradients in x and y directions respectively

    """
    gx = gy = np.zeros_like(img)

    dx = [[1, 0, -1],[ 1, 0, -1], [1, 0, -1]]
    dy = [[1, 1, 1], [0, 0, 0], [-1, -1, -1]]

#     dx = [[0, 1],[-1, 0]]
#     dy = [[1, 0], [0, -1]]

    gx = ndimage.correlate(img, dx, mode='constant', cval=0.0)
    gy = ndimage.correlate(img, dy, mode='constant', cval=0.0)
    ##########################################################################
    # TODO: Design a pure differentiation filter and use correlation to      #
    # compute the gradients gx and gy. You might have to try multiple        #
    # filters till the test below passes. All the tests after will fail if   #
    # this one does not pass.                                                #
    ##########################################################################
    return gx, gy

def energy_image(img):
    """
    Computes the energy of the input image according to the energy function:

        e(I) = abs(dI/dx) + abs(dI/dy)

    Use compute_gradients() to help you calculate the energy image. Remember to normalize
    energyImage by dividing it by max(energyImage).

    Input: image of the form (H x W) or (H x w x 3)
    Output: array of energy values of the image computed according to the energy function.

    """
    if img.ndim > 2:
        img = rgb2gray(img)

    gx, gy = compute_gradients(img)
    energyImage = np.abs(gx) + np.abs(gy)
    energyImage = energyImage / float(np.max(energyImage))


    ##########################################################################
    # TODO: Compute the energy of input using the defined energy function.   #                                             #
    ##########################################################################

    return energyImage

def cumulative_minimum_energy_map(energyImage, seamDirection):
    """
    Calculates the cumulative minim energy map according to the function:

        M(i, j) = e(i, j) + min(M(i-1, j-1), M(i-1, j), M(i-1, j+1))

    Inputs:
        energyImage: Results of passign the input image to energy_image()
        seamDirection: 'HORIZONTAL' or 'VERTICAL'

    Output: cumulativeEnergyMap

    """


    cumulativeEnergyMap = np.zeros_like(energyImage)
    if seamDirection == 'HORIZONTAL':
        for i in range(0,cumulativeEnergyMap.shape[0]):
             cumulativeEnergyMap[i,0] = energyImage[i,0]

        for j in range(1,cumulativeEnergyMap.shape[1]):
            cumulativeEnergyMap[0,j] = energyImage[0,j] + min(cumulativeEnergyMap[0,j-1], cumulativeEnergyMap[1,j-1])
            for i in range(1,cumulativeEnergyMap.shape[0]-1):
                cumulativeEnergyMap[i,j] = energyImage[i,j] + min(cumulativeEnergyMap[i-1,j-1], cumulativeEnergyMap[i,j-1], cumulativeEnergyMap[i+1,j-1])
            last = cumulativeEnergyMap.shape[0]-1
            cumulativeEnergyMap[last,j] = energyImage[last,j] + min(cumulativeEnergyMap[last-1,j-1], cumulativeEnergyMap[last,j-1])
    elif seamDirection == 'VERTICAL':
        for j in range(0,cumulativeEnergyMap.shape[1]):
            cumulativeEnergyMap[0,j] = energyImage[0,j]

        for i in range(1,cumulativeEnergyMap.shape[0]):
            cumulativeEnergyMap[i,0] = energyImage[i,0] + min(cumulativeEnergyMap[i-1,0], cumulativeEnergyMap[i-1,1])
            for j in range(1,cumulativeEnergyMap.shape[1]-1):
                cumulativeEnergyMap[i,j] = energyImage[i,j] + min(cumulativeEnergyMap[i-1,j-1], cumulativeEnergyMap[i-1,j], cumulativeEnergyMap[i-1,j+1])
            last = cumulativeEnergyMap.shape[1]-1
            cumulativeEnergyMap[i,last] = energyImage[i,last] + min(cumulativeEnergyMap[i-1,last-1], cumulativeEnergyMap[i-1,last])
    else:
        print("No seam direction specified")

    ##########################################################################
    # TODO: Compute the cumulative minimum energy map in the input           #
    # seamDirection for the input energyImage. It is fine it is not fully    #
    # vectorized.                                                            #
    ##########################################################################

    return cumulativeEnergyMap

def find_optimal_vertical_seam(cumulativeEnergyMap):
    """
    Finds the least connected vertical seam using a vertical cumulative minimum energy map.

    Input: Vertical cumulative minimum energy map.
    Output:
        verticalSeam: vector containing column indices of the pixels in making up the seam.

    """

    verticalSeam = [0]*cumulativeEnergyMap.shape[0]
    verticalSeam[cumulativeEnergyMap.shape[0]-1] = np.argmin(cumulativeEnergyMap[cumulativeEnergyMap.shape[0]-1, : ])
    for i in range(cumulativeEnergyMap.shape[0]-2, -1, -1):
        lastj = verticalSeam[i+1] # get last rows optimal column
        if lastj == cumulativeEnergyMap.shape[1]-1:
            verticalSeam[i] = lastj-1 + np.argmin(cumulativeEnergyMap[i, lastj-1:lastj+1]) # Looking at the pixel above last min and above and to the left
        elif lastj == 0:
            verticalSeam[i] = lastj + np.argmin(cumulativeEnergyMap[i, lastj:lastj+2]) # Looking at the pixel above last min and above and to the right
        else:
            verticalSeam[i] = lastj-1 + np.argmin(cumulativeEnergyMap[i, lastj-1:lastj+2]) # Looking at the 3 pixels in the current row above the last min


    ##########################################################################
    # TODO: Find the minimal connected vertical seam using the input         #
    # cumulative minimum energy map.                                         #
    ##########################################################################

    return verticalSeam

def find_optimal_horizontal_seam(cumulativeEnergyMap):
    """
    Finds the least connected horizontal seam using a horizontal cumulative minimum energy map.

    Input: Horizontal cumulative minimum energy map.
    Output:
        horizontalSeam: vector containing row indices of the pixels in making up the seam.

    """
    horizontalSeam = [0]*cumulativeEnergyMap.shape[1]
    horizontalSeam[cumulativeEnergyMap.shape[1]-1] = np.argmin(cumulativeEnergyMap[ : , cumulativeEnergyMap.shape[1]-1])
    for j in range(cumulativeEnergyMap.shape[1]-2, -1, -1):
        lasti = horizontalSeam[j+1] # get last rows optimal column
        if lasti == cumulativeEnergyMap.shape[0]-1:
            horizontalSeam[j] = lasti-1 + np.argmin(cumulativeEnergyMap[lasti-1:lasti+1, j]) # Looking at the pixel above last min and above and to the left
        elif lasti == 0:
            horizontalSeam[j] = lasti + np.argmin(cumulativeEnergyMap[lasti:lasti+2, j] ) # Looking at the pixel above last min and above and to the right
        else:
            horizontalSeam[j] = lasti-1 + np.argmin(cumulativeEnergyMap[lasti-1:lasti+2, j] ) # Looking at the 3 pixels in the current row above the last min


    ##########################################################################
    # TODO: Find the minimal connected horizontal seam using the input       #
    # cumulative minimum energy map.                                         #
    ##########################################################################

    return horizontalSeam

def reduce_width(img, energyImage):
    """
    Removes pixels along a seam, reducing the width of the input image by 1 pixel.

    Inputs:
        img: RGB image of shape (H x W x 3) from which a seam is to be removed.
        energyImage: The energy image of the input image.

    Outputs:
        reducedColorImage: The input image whose width has been reduced by 1 pixel
        reducedEnergyImage: The energy image whose width has been reduced by 1 pixel
    """
    reducedEnergyImageSize = (energyImage.shape[0], energyImage.shape[1] - 1)
    reducedColorImageSize = (img.shape[0], img.shape[1] - 1, 3)

    reducedColorImage = np.zeros(reducedColorImageSize)
    reducedEnergyImage = np.zeros(reducedEnergyImageSize)

    verticalEnergyMap = cumulative_minimum_energy_map(energyImage, 'VERTICAL')
    seam = find_optimal_vertical_seam(verticalEnergyMap)

    for i in range(img.shape[0]):
        reducedColorImage[i] = np.delete(img[i,:], seam[i], axis=0)
        reducedEnergyImage[i] = np.delete(energyImage[i,:], seam[i])


    ##########################################################################
    # TODO: Compute the cumulative minimum energy map and find the minimal   #
    # connected vertical seam. Then, remove the pixels along this seam.      #
    ##########################################################################

    return reducedColorImage, reducedEnergyImage

def reduce_height(img, energyImage):
    """
    Removes pixels along a seam, reducing the height of the input image by 1 pixel.

    Inputs:
        img: RGB image of shape (H x W x 3) from which a seam is to be removed.
        energyImage: The energy image of the input image.

    Outputs:
        reducedColorImage: The input image whose height has been reduced by 1 pixel
        reducedEnergyImage: The energy image whose height has been reduced by 1 pixel
    """

    reducedEnergyImageSize = tuple((energyImage.shape[0] - 1, energyImage.shape[1]))
    reducedColorImageSize = tuple((img.shape[0] - 1, img.shape[1], 3))

    reducedColorImage = np.zeros(reducedColorImageSize)
    reducedEnergyImage = np.zeros(reducedEnergyImageSize)

    horizontalEnergyMap = cumulative_minimum_energy_map(energyImage, 'HORIZONTAL')
    seam = find_optimal_horizontal_seam(horizontalEnergyMap)

    for j in range(img.shape[1]):
        reducedColorImage[:,j] = np.delete(img[:,j], seam[j], axis=0)
        reducedEnergyImage[:,j] = np.delete(energyImage[:,j], seam[j])

    ##########################################################################
    # TODO: Compute the cumulative minimum energy map and find the minimal   #
    # connected horizontal seam. Then, remove the pixels along this seam.    #
    ##########################################################################

    return reducedColorImage, reducedEnergyImage

def seam_carving_reduce_width(img, reduceBy):
    """
    Reduces the width of the input image by the number pixels passed in reduceBy.

    Inputs:
        img: Input image of shape (H x W X 3)
        reduceBy: Positive non-zero integer indicating the number of pixels the width
        should be reduced by.

    Output:
        reducedColorImage: The result of removing reduceBy number of vertical seams.
    """

    tempColorImage = np.copy(img)

    for i in range(reduceBy):
        tempColorImage, tempEnergyImage = reduce_width(tempColorImage, energy_image(tempColorImage))
    reducedColorImage = tempColorImage.astype(np.uint8)

    ##########################################################################
    # TODO: For the Prague image, write a few lines of code to call the      #
    # we have written to find and remove 100 vertical seams                  #
    ##########################################################################

    return reducedColorImage

def seam_carving_reduce_height(img, reduceBy):
    """
    Reduces the height of the input image by the number pixels passed in reduceBy.

    Inputs:
        img: Input image of shape (H x W X 3)
        reduceBy: Positive non-zero integer indicating the number of pixels the
        height should be reduced by.

    Output:
        reducedColorImage: The result of removing reduceBy number of horizontal
        seams.
    """

    tempColorImage = np.copy(img)

    for i in range(reduceBy):
        tempColorImage, tempEnergyImage = reduce_height(tempColorImage, energy_image(tempColorImage))
    reducedColorImage = tempColorImage.astype(np.uint8)

    ##########################################################################
    # TODO: For the Prague image, write a few lines of code to call the      #
    # we have written to find and remove 100 horizontal seams.               #
    ##########################################################################

    return reducedColorImage